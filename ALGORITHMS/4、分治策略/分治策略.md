<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">





# 第4章 分治策略

## 4.3 用代入法求解递归式

> 代入法求解递归式分为两步：
>
> 1. 猜测解的形式
> 2. 用数学归纳法求出解中的常数，并证明解是正确的。		

## 4.4用递归树方法求解递归式

> 1. 计算树的深度
> 2. 计算树每层代价
> 3. 计算总复杂度

## 4.5用主方法求解递归式

递归式描述的是这样一种算法的运行时间：它将规模为$n$的问题分解为$a$个子问题，每个子问题规模为$n/b$，其中$a$和$b$都是正常数。$f(n)$是渐近正函数。

> 定理4.1（主定理）令$a\ge1$和$b\gt1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：
> $$
> T(n) = aT(n/b) + f(n)
> $$
> 其中我们将$b/n$解释为$\lfloor b/n \rfloor$或$\lceil b/n \rceil$。那么$T(n)$有如下渐近界：
>
> 1. 若对某个常数$\epsilon \gt 0$有$f(n) = \Omicron (n ^ {log_b a-\epsilon})$，则$T(n) = \Theta (n^{log_b a}) $。
> 2. 若$f(n) = \Theta (n ^ {log_b a})$，则$T(n) = \Theta (n^{lob_b a} lgn) $。
> 3. 若对某个常数$\epsilon \gt 0$有$f(n) = \Omega (n ^ {log_b a+\epsilon})$，且对某个常数$c \lt 1$和所有足够大的$n$有$af(n/b) \le cf(n)$，则$T(n) = \Theta (f(n)) $。

意义：

​		将函数$f(n)$与函数$n^ {lag_b a}$进行比较。直觉上，两个函数较大者决定了递归式的解。

</script>
